import{_ as s,o as n,c as o,Q as a}from"./chunks/framework.97257f7d.js";const f=JSON.parse('{"title":"原形链","description":"","frontmatter":{},"headers":[],"relativePath":"es6/prototype.md","filePath":"es6/prototype.md"}'),p={name:"es6/prototype.md"},l=a(`<h1 id="原形链" tabindex="-1">原形链 <a class="header-anchor" href="#原形链" aria-label="Permalink to &quot;原形链&quot;">​</a></h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki solarized-light vp-code-dark"><code><span class="line"><span style="color:#657B83;"> </span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//一个构造函数Foo</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#586E75;font-weight:bold;">function</span><span style="color:#657B83;"> </span><span style="color:#268BD2;">Foo</span><span style="color:#657B83;">() {  }</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//一个f1实例对象</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#586E75;font-weight:bold;">let</span><span style="color:#657B83;"> </span><span style="color:#268BD2;">f1</span><span style="color:#657B83;"> </span><span style="color:#859900;">=</span><span style="color:#657B83;"> </span><span style="color:#859900;">new</span><span style="color:#657B83;"> </span><span style="color:#268BD2;">Foo</span><span style="color:#657B83;">()</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//翻译:f1是Foo的实例对象吗？</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//还记得我说过，一个实例对象通过proto指向其构造函数的原型对象上。</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//深入翻译：f1这个实例对象通过proto指向是否可以找到Foo.prototype上呢？</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">f1</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;"> </span><span style="color:#CB4B16;">Foo</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//这行代码可以得出，沿着proto只找了一层就找到了。</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">f1</span><span style="color:#657B83;">.__proto__ </span><span style="color:#859900;">===</span><span style="color:#657B83;"> </span><span style="color:#859900;">Foo</span><span style="color:#657B83;">.prototype);   </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//翻译：f1是Object的实例对象吗？</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//深入翻译：f1这个实例对象通过proto指向是否可以找到Object.prototype上呢？</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">f1</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;"> </span><span style="color:#CB4B16;">Object</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//这两行代码可以得出，沿着proto找了两层才找到。事实上，f1.__proto__找到了Foo.prototype（Foo构造函数原型上），再次去.__proto__，找到了Object的原型对象上。见下图。</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">f1</span><span style="color:#657B83;">.__proto__ </span><span style="color:#859900;">===</span><span style="color:#657B83;"> </span><span style="color:#859900;">Object</span><span style="color:#657B83;">.prototype);  </span><span style="color:#93A1A1;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">f1</span><span style="color:#657B83;">.__proto__.__proto__ </span><span style="color:#859900;">===</span><span style="color:#657B83;"> </span><span style="color:#859900;">Object</span><span style="color:#657B83;">.prototype);  </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//这个案例的实质还是那句话：一个实例对象通过proto属性指向其构造函数的原型对象上。</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">//翻译：实例对象Object是否可以通过proto属性（沿着原型链）找到Function.prototype（Function的原型对象）</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">Object</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;"> </span><span style="color:#CB4B16;">Function</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">//以上结果的输出可以看到下图，Object.__proto__直接找到一层就是Function.prototype.（Object created by Function）可知Object构造函数是由Function创建出来的，也就是说，Object这个实例是new Function出来的。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">Object</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;"> </span><span style="color:#CB4B16;">Object</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">//很有意思。上面我们已经知道Object这个实例是new Function出来的。也就是Object.proto指向Function.prototype。有意思的是，Function的原型对象又是Object原型对象的一个实例，也就是Function.prototype.proto 指向  Object.prototype .很有意思吧，见下图很更清楚这个“走向”。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">Function</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;"> </span><span style="color:#CB4B16;">Function</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">//由这个可知，可以验证我们的结论：Function是通过new自己产生的实例。                                        Function.proto===Function.prototype</span></span>
<span class="line"></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">Function</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;"> </span><span style="color:#CB4B16;">Object</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">//Function.proto.proto===Function.prototype (找了两层)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#93A1A1;font-style:italic;">//定义了一个Foo构造函数。由下图可知，Foo.proto.proto.proto===null</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#586E75;font-weight:bold;">function</span><span style="color:#657B83;"> </span><span style="color:#268BD2;">Foo</span><span style="color:#657B83;">() {}</span></span>
<span class="line"><span style="color:#657B83;">  </span><span style="color:#268BD2;">console</span><span style="color:#657B83;">.</span><span style="color:#268BD2;">log</span><span style="color:#657B83;">(</span><span style="color:#268BD2;">Object</span><span style="color:#657B83;"> </span><span style="color:#859900;">instanceof</span><span style="color:#657B83;">  </span><span style="color:#CB4B16;">Foo</span><span style="color:#657B83;">) </span><span style="color:#93A1A1;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">//这条语句要验证的是，Object是否可以通过其原型链找到Foo.prototype。</span></span>
<span class="line"><span style="color:#93A1A1;font-style:italic;">// Object.proto.proto.proto=null  并不会找到Foo.prototype。所以，返回FALSE。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//一个构造函数Foo</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Foo</span><span style="color:#24292E;">() {  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//一个f1实例对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> f1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Foo</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//翻译:f1是Foo的实例对象吗？</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//还记得我说过，一个实例对象通过proto指向其构造函数的原型对象上。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//深入翻译：f1这个实例对象通过proto指向是否可以找到Foo.prototype上呢？</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(f1 </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Foo</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//这行代码可以得出，沿着proto只找了一层就找到了。</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(f1.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Foo</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//翻译：f1是Object的实例对象吗？</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//深入翻译：f1这个实例对象通过proto指向是否可以找到Object.prototype上呢？</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(f1 </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//这两行代码可以得出，沿着proto找了两层才找到。事实上，f1.__proto__找到了Foo.prototype（Foo构造函数原型上），再次去.__proto__，找到了Object的原型对象上。见下图。</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(f1.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Object</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(f1.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Object</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">);  </span><span style="color:#6A737D;">// true</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//这个案例的实质还是那句话：一个实例对象通过proto属性指向其构造函数的原型对象上。</span></span>
<span class="line"><span style="color:#6A737D;">//翻译：实例对象Object是否可以通过proto属性（沿着原型链）找到Function.prototype（Function的原型对象）</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(Object </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Function</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#6A737D;">//以上结果的输出可以看到下图，Object.__proto__直接找到一层就是Function.prototype.（Object created by Function）可知Object构造函数是由Function创建出来的，也就是说，Object这个实例是new Function出来的。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(Object </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#6A737D;">//很有意思。上面我们已经知道Object这个实例是new Function出来的。也就是Object.proto指向Function.prototype。有意思的是，Function的原型对象又是Object原型对象的一个实例，也就是Function.prototype.proto 指向  Object.prototype .很有意思吧，见下图很更清楚这个“走向”。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(Function </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Function</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#6A737D;">//由这个可知，可以验证我们的结论：Function是通过new自己产生的实例。                                        Function.proto===Function.prototype</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(Function </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#6A737D;">//Function.proto.proto===Function.prototype (找了两层)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//定义了一个Foo构造函数。由下图可知，Foo.proto.proto.proto===null</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Foo</span><span style="color:#24292E;">() {}</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(Object </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">Foo</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#6A737D;">//这条语句要验证的是，Object是否可以通过其原型链找到Foo.prototype。</span></span>
<span class="line"><span style="color:#6A737D;">// Object.proto.proto.proto=null  并不会找到Foo.prototype。所以，返回FALSE。</span></span></code></pre></div>`,2),t=[l];function e(c,r,y,i,B,A){return n(),o("div",null,t)}const _=s(p,[["render",e]]);export{f as __pageData,_ as default};
